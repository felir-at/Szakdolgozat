#include <windows.h>
#include <detours.h>
#include <stdio.h>

#include <QtCore/QObject>
#include <QtCore/qobjectdefs.h>

typedef int (WINAPI qt_metacall_signature)(QMetaObject::Call _c, int _id, void **_a);

#define METACALL(function, _c, _id, _a, ret_var) __asm {\
    __asm mov ecx, _this\
    __asm push _a\
    __asm push _id\
    __asm push _c\
    __asm call function\
    __asm mov ret_var, eax\
}

{{#classes}}
qt_metacall_signature* {{metacall_address_name}} = (qt_metacall_signature*)(void*){{metacall_function_address}};
qt_metacall_signature* {{metacall_address_name}}_super = *(qt_metacall_signature**){{metacall_super_function_address}};


int WINAPI {{metacall_hook_name}}(QMetaObject::Call _c, int _id, void **_a) {
    void *_this;
    int ret_id;
    __asm mov _this, ecx
    METACALL({{metacall_address_name}}_super, _c, _id, _a, ret_id)
    if (ret_id < 0) {
        return ret_id;
    } else {
        METACALL({{metacall_address_name}}, _c, _id, _a, _id)
        return _id;
    }
}
{{/classes}}

BOOL DllProcessAttach(HINSTANCE hinst) {
    LONG errCode;
    if (NO_ERROR != (errCode = DetourTransactionBegin())) {
        switch (errCode) {
            case ERROR_INVALID_OPERATION:
                printf("DetourTransactionBegin failed\n\tA pending transaction alrady exists.");
                break;
        }
        return FALSE;
    }
    DisableThreadLibraryCalls(hinst);
    if (NO_ERROR != (errCode = DetourUpdateThread(GetCurrentThread()))) {
        switch (errCode) {
            case ERROR_NOT_ENOUGH_MEMORY:
                printf("DetourUpdateThread failed\n\tNot enough memory to record identity of thread.");
                break;
        }
        DetourTransactionAbort();
        return FALSE;
    }
    {{#classes}}
        if (NO_ERROR != (errCode = DetourAttach(&(PVOID&){{metacall_address_name}}, &{{metacall_hook_name}}))) {
            switch (errCode) {
                case ERROR_INVALID_BLOCK:
                    printf("DetourAttach failed\n\tThe function referenced is too small to be detoured.");
                    break;
                case ERROR_INVALID_HANDLE:
                    printf("DetourAttach failed\n\tThe ppPointer parameter is null or points to a null pointer.");
                    break;
                case ERROR_INVALID_OPERATION:
                    printf("DetourAttach failed\n\tNo pending transaction exists.");
                    break;
                case ERROR_NOT_ENOUGH_MEMORY:
                    printf("DetourAttach failed\n\tNot enough memory exists to complete the operation.");
                    break;
            }
            DetourTransactionAbort();
            return FALSE;
        }
    {{/classes}}
    if (NO_ERROR != (errCode = DetourTransactionCommit())) {
        switch (errCode) {
            case ERROR_INVALID_DATA:
                printf("DetourTransactionCommit failed. Target function was changed by third party between steps of the transaction.");
                break;
            case ERROR_INVALID_OPERATION:
                printf("DetourTransactionCommit failed. No pending transaction exists.");
                break;
            default:
                printf("DetourTransactionCommit failed. Other error.");
                break;
        }
        DetourTransactionAbort();
        return FALSE;
    }
    return TRUE;
}

BOOL DllProcessDetach() {
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    {{#classes}}
    DetourDetach(&(PVOID&){{metacall_address_name}}, {{metacall_hook_name}});
    {{/classes}}
    DetourTransactionCommit();
    return TRUE;
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach(hinst);
        case DLL_PROCESS_DETACH:
            return DllProcessDetach();
        default:
            return TRUE;
    }
}

